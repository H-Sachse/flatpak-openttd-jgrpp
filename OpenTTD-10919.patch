From cbc649c6ab638144c20d6efc44c99de2326e6c06 Mon Sep 17 00:00:00 2001
From: Patric Stout <truebrain@openttd.org>
Date: Sat, 3 Jun 2023 23:08:37 +0200
Subject: [PATCH 1/3] Fix: [SDL] unify the way X11 and Wayland handle mouse
 events

Basically, we drop RelativeMode completely, and use the same trick
as used by the Windows driver: read all motion events till the last
one, and use that as value.
---
 src/video/sdl2_v.cpp | 22 +++++++++++++++-------
 src/video/sdl_v.cpp  | 17 +++++++++++++++--
 2 files changed, 30 insertions(+), 9 deletions(-)

diff --git a/src/video/sdl2_v.cpp b/src/video/sdl2_v.cpp
index 6f6cb5156172..f455fdd7c7a3 100644
--- a/src/video/sdl2_v.cpp
+++ b/src/video/sdl2_v.cpp
@@ -371,12 +371,25 @@ bool VideoDriver_SDL_Base::PollEvent()
 	if (!SDL_PollEvent(&ev)) return false;
 
 	switch (ev.type) {
-		case SDL_MOUSEMOTION:
-			if (_cursor.UpdateCursorPosition(ev.motion.x, ev.motion.y, true)) {
+		case SDL_MOUSEMOTION: {
+			int32_t x = ev.motion.x;
+			int32_t y = ev.motion.y;
+
+			if (_cursor.fix_at) {
+				/* Get all queued mouse events now in case we have to warp the cursor. In the
+				 * end, we only care about the current mouse position and not bygone events. */
+				while (SDL_PeepEvents(&ev, 1, SDL_GETEVENT, SDL_MOUSEMOTION, SDL_MOUSEMOTION)) {
+					x = ev.motion.x;
+					y = ev.motion.y;
+				}
+			}
+
+			if (_cursor.UpdateCursorPosition(x, y, false)) {
 				SDL_WarpMouseInWindow(this->sdl_window, _cursor.pos.x, _cursor.pos.y);
 			}
 			HandleMouseEvents();
 			break;
+		}
 
 		case SDL_MOUSEWHEEL:
 			if (ev.wheel.y > 0) {
@@ -478,10 +491,8 @@ bool VideoDriver_SDL_Base::PollEvent()
 			} else if (ev.window.event == SDL_WINDOWEVENT_ENTER) {
 				// mouse entered the window, enable cursor
 				_cursor.in_window = true;
-#ifdef __EMSCRIPTEN__
 				/* Ensure pointer lock will not occur. */
 				SDL_SetRelativeMouseMode(SDL_FALSE);
-#endif
 			} else if (ev.window.event == SDL_WINDOWEVENT_LEAVE) {
 				// mouse left the window, undraw cursor
 				UndrawMouseCursor();
@@ -500,9 +511,6 @@ static const char *InitializeSDL()
 	 * UpdateWindowSurface() to update the window's texture instead of
 	 * its surface. */
 	SDL_SetHint(SDL_HINT_FRAMEBUFFER_ACCELERATION, "0");
-#ifndef __EMSCRIPTEN__
-	SDL_SetHint(SDL_HINT_MOUSE_RELATIVE_MODE_WARP, "1");
-#endif
 
 	/* Check if the video-driver is already initialized. */
 	if (SDL_WasInit(SDL_INIT_VIDEO) != 0) return nullptr;
diff --git a/src/video/sdl_v.cpp b/src/video/sdl_v.cpp
index dde67c909b04..4f02bf36e39b 100644
--- a/src/video/sdl_v.cpp
+++ b/src/video/sdl_v.cpp
@@ -478,12 +478,25 @@ bool VideoDriver_SDL::PollEvent()
 	if (!SDL_PollEvent(&ev)) return false;
 
 	switch (ev.type) {
-		case SDL_MOUSEMOTION:
-			if (_cursor.UpdateCursorPosition(ev.motion.x, ev.motion.y, true)) {
+		case SDL_MOUSEMOTION: {
+			int32_t x = ev.motion.x;
+			int32_t y = ev.motion.y;
+
+			if (_cursor.fix_at) {
+				/* Get all queued mouse events now in case we have to warp the cursor. In the
+				 * end, we only care about the current mouse position and not bygone events. */
+				while (SDL_PeepEvents(&ev, 1, SDL_GETEVENT, SDL_MOUSEMOTION)) {
+					x = ev.motion.x;
+					y = ev.motion.y;
+				}
+			}
+
+			if (_cursor.UpdateCursorPosition(x, y, false)) {
 				SDL_WarpMouse(_cursor.pos.x, _cursor.pos.y);
 			}
 			HandleMouseEvents();
 			break;
+		}
 
 		case SDL_MOUSEBUTTONDOWN:
 			if (_rightclick_emulate && SDL_GetModState() & KMOD_CTRL) {

From a8cd259d40aef1893182bf1c3ab9bf517edd1a6e Mon Sep 17 00:00:00 2001
From: Patric Stout <truebrain@openttd.org>
Date: Sat, 3 Jun 2023 23:09:41 +0200
Subject: [PATCH 2/3] Codechange: simplify UpdateCursorPositionRelative

The function is only called with fix_at=true, so don't support
the other cases.
---
 src/gfx.cpp | 20 +++++---------------
 1 file changed, 5 insertions(+), 15 deletions(-)

diff --git a/src/gfx.cpp b/src/gfx.cpp
index 4d268e3dbe2e..08a2f6277930 100644
--- a/src/gfx.cpp
+++ b/src/gfx.cpp
@@ -1880,27 +1880,17 @@ void SetAnimatedMouseCursor(const AnimCursor *table)
 }
 
 /**
- * Update cursor position on mouse movement for relative modes.
+ * Update cursor position based on a relative change.
+ *
  * @param delta_x How much change in the X position.
  * @param delta_y How much change in the Y position.
  */
 void CursorVars::UpdateCursorPositionRelative(int delta_x, int delta_y)
 {
-	if (this->fix_at) {
-		this->delta.x = delta_x;
-		this->delta.y = delta_y;
-	} else {
-		int last_position_x = this->pos.x;
-		int last_position_y = this->pos.y;
-
-		this->pos.x = Clamp(this->pos.x + delta_x, 0, _cur_resolution.width - 1);
-		this->pos.y = Clamp(this->pos.y + delta_y, 0, _cur_resolution.height - 1);
+	assert(this->fix_at);
 
-		this->delta.x = last_position_x - this->pos.x;
-		this->delta.y = last_position_y - this->pos.y;
-
-		this->dirty = true;
-	}
+	this->delta.x = delta_x;
+	this->delta.y = delta_y;
 }
 
 /**

From 53b0c2ad0aee9b9422349eb2038561acff26bfd7 Mon Sep 17 00:00:00 2001
From: Patric Stout <truebrain@openttd.org>
Date: Sat, 3 Jun 2023 23:10:16 +0200
Subject: [PATCH 3/3] Codechange: remove queue_wrap / last_position from mouse
 movement

No backend uses it anymore, so also no longer any need to support
it.
---
 src/gfx.cpp                  | 40 ++++++------------------------------
 src/gfx_type.h               |  6 +-----
 src/video/allegro_v.cpp      |  2 +-
 src/video/cocoa/cocoa_wnd.mm |  2 +-
 src/video/sdl2_v.cpp         |  2 +-
 src/video/sdl_v.cpp          |  2 +-
 src/video/win32_v.cpp        |  2 +-
 7 files changed, 12 insertions(+), 44 deletions(-)

diff --git a/src/gfx.cpp b/src/gfx.cpp
index 08a2f6277930..2f9e71c95be2 100644
--- a/src/gfx.cpp
+++ b/src/gfx.cpp
@@ -1897,50 +1897,22 @@ void CursorVars::UpdateCursorPositionRelative(int delta_x, int delta_y)
  * Update cursor position on mouse movement.
  * @param x New X position.
  * @param y New Y position.
- * @param queued_warp True, if the OS queues mouse warps after pending mouse movement events.
- *                    False, if the warp applies instantaneous.
  * @return true, if the OS cursor position should be warped back to this->pos.
  */
-bool CursorVars::UpdateCursorPosition(int x, int y, bool queued_warp)
+bool CursorVars::UpdateCursorPosition(int x, int y)
 {
-	/* Detecting relative mouse movement is somewhat tricky.
-	 *  - There may be multiple mouse move events in the video driver queue (esp. when OpenTTD lags a bit).
-	 *  - When we request warping the mouse position (return true), a mouse move event is appended at the end of the queue.
-	 *
-	 * So, when this->fix_at is active, we use the following strategy:
-	 *  - The first movement triggers the warp to reset the mouse position.
-	 *  - Subsequent events have to compute movement relative to the previous event.
-	 *  - The relative movement is finished, when we receive the event matching the warp.
-	 */
-
-	if (x == this->pos.x && y == this->pos.y) {
-		/* Warp finished. */
-		this->queued_warp = false;
-	}
+	this->delta.x = x - this->pos.x;
+	this->delta.y = y - this->pos.y;
 
-	this->delta.x = x - (this->queued_warp ? this->last_position.x : this->pos.x);
-	this->delta.y = y - (this->queued_warp ? this->last_position.y : this->pos.y);
-
-	this->last_position.x = x;
-	this->last_position.y = y;
-
-	bool need_warp = false;
 	if (this->fix_at) {
-		if (this->delta.x != 0 || this->delta.y != 0) {
-			/* Trigger warp.
-			 * Note: We also trigger warping again, if there is already a pending warp.
-			 *       This makes it more tolerant about the OS or other software in between
-			 *       botchering the warp. */
-			this->queued_warp = queued_warp;
-			need_warp = true;
-		}
+		return this->delta.x != 0 || this->delta.y != 0;
 	} else if (this->pos.x != x || this->pos.y != y) {
-		this->queued_warp = false; // Cancel warping, we are no longer confining the position.
 		this->dirty = true;
 		this->pos.x = x;
 		this->pos.y = y;
 	}
-	return need_warp;
+
+	return false;
 }
 
 bool ChangeResInGame(int width, int height)
diff --git a/src/gfx_type.h b/src/gfx_type.h
index 50ac4f68929c..55f6a361a220 100644
--- a/src/gfx_type.h
+++ b/src/gfx_type.h
@@ -144,11 +144,7 @@ struct CursorVars {
 	bool vehchain;                ///< vehicle chain is dragged
 
 	void UpdateCursorPositionRelative(int delta_x, int delta_y);
-	bool UpdateCursorPosition(int x, int y, bool queued_warp);
-
-private:
-	bool queued_warp;
-	Point last_position;
+	bool UpdateCursorPosition(int x, int y);
 };
 
 /** Data about how and where to blit pixels. */
diff --git a/src/video/allegro_v.cpp b/src/video/allegro_v.cpp
index 21386f34055f..5cf0c5852a38 100644
--- a/src/video/allegro_v.cpp
+++ b/src/video/allegro_v.cpp
@@ -391,7 +391,7 @@ bool VideoDriver_Allegro::PollEvent()
 	}
 
 	/* Mouse movement */
-	if (_cursor.UpdateCursorPosition(mouse_x, mouse_y, false)) {
+	if (_cursor.UpdateCursorPosition(mouse_x, mouse_y)) {
 		position_mouse(_cursor.pos.x, _cursor.pos.y);
 	}
 	if (_cursor.delta.x != 0 || _cursor.delta.y) mouse_action = true;
diff --git a/src/video/cocoa/cocoa_wnd.mm b/src/video/cocoa/cocoa_wnd.mm
index df08df857f1b..17d986973121 100644
--- a/src/video/cocoa/cocoa_wnd.mm
+++ b/src/video/cocoa/cocoa_wnd.mm
@@ -658,7 +658,7 @@ - (void)internalMouseMoveEvent:(NSEvent *)event
 		_cursor.UpdateCursorPositionRelative(event.deltaX * self.getContentsScale, event.deltaY * self.getContentsScale);
 	} else {
 		NSPoint pt = [ self mousePositionFromEvent:event ];
-		_cursor.UpdateCursorPosition(pt.x, pt.y, false);
+		_cursor.UpdateCursorPosition(pt.x, pt.y);
 	}
 
 	HandleMouseEvents();
diff --git a/src/video/sdl2_v.cpp b/src/video/sdl2_v.cpp
index f455fdd7c7a3..72734e03d444 100644
--- a/src/video/sdl2_v.cpp
+++ b/src/video/sdl2_v.cpp
@@ -384,7 +384,7 @@ bool VideoDriver_SDL_Base::PollEvent()
 				}
 			}
 
-			if (_cursor.UpdateCursorPosition(x, y, false)) {
+			if (_cursor.UpdateCursorPosition(x, y)) {
 				SDL_WarpMouseInWindow(this->sdl_window, _cursor.pos.x, _cursor.pos.y);
 			}
 			HandleMouseEvents();
diff --git a/src/video/sdl_v.cpp b/src/video/sdl_v.cpp
index 4f02bf36e39b..eb05f32797b3 100644
--- a/src/video/sdl_v.cpp
+++ b/src/video/sdl_v.cpp
@@ -491,7 +491,7 @@ bool VideoDriver_SDL::PollEvent()
 				}
 			}
 
-			if (_cursor.UpdateCursorPosition(x, y, false)) {
+			if (_cursor.UpdateCursorPosition(x, y)) {
 				SDL_WarpMouse(_cursor.pos.x, _cursor.pos.y);
 			}
 			HandleMouseEvents();
diff --git a/src/video/win32_v.cpp b/src/video/win32_v.cpp
index b1c8cafae5a6..7b06809a5559 100644
--- a/src/video/win32_v.cpp
+++ b/src/video/win32_v.cpp
@@ -490,7 +490,7 @@ LRESULT CALLBACK WndProcGdi(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 				}
 			}
 
-			if (_cursor.UpdateCursorPosition(x, y, false)) {
+			if (_cursor.UpdateCursorPosition(x, y)) {
 				POINT pt;
 				pt.x = _cursor.pos.x;
 				pt.y = _cursor.pos.y;
